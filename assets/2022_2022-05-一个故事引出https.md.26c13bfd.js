import{_ as s,c as a,o as n,a as l}from"./app.7f1206cf.js";const i=JSON.parse('{"title":"2022-12-一个故事引出HTTPS","description":"","frontmatter":{},"headers":[],"relativePath":"2022/2022-05-一个故事引出https.md","lastUpdated":1676736399000}'),p={name:"2022/2022-05-一个故事引出https.md"},o=l(`<h1 id="_2022-12-一个故事引出https" tabindex="-1">2022-12-一个故事引出HTTPS <a class="header-anchor" href="#_2022-12-一个故事引出https" aria-hidden="true">#</a></h1><h2 id="_1-一道故事题" tabindex="-1">1. 一道故事题 <a class="header-anchor" href="#_1-一道故事题" aria-hidden="true">#</a></h2><blockquote><p>A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？</p></blockquote><p>逻辑解法，A上锁，C拿着箱子给B，B上锁，C拿着箱子再给A，A解锁，C拿着箱子给B，B解锁，拿药。但这个解法在算法上不成立，因为是两个同级锁，现在做不到。可能的做法是，A用自己的公钥加密，B用自己的公钥外层加密，但A拿到后无法再解密，这个思路是走不通的。所以直接A使用B的公钥加密，B拿到后用自己的私钥解密即可。那么为什么A会有B的公钥呢？现在都是第三方提供公钥，私钥自己留着，把公钥交给第三方机构。</p><blockquote><p>公钥加密，私钥解密，主要用于通信；a-&gt;rs(a)是加密。 私钥签名，公钥验证，主要用于签名；a-&gt;a&amp;sign(a)是签名。</p></blockquote><p>做APP支付的时候，需要去支付宝的后台配置自己的公钥，支付的时候，需要把商品信息用自己的私钥去签名，给支付宝，支付宝用你填写的公钥去验证。</p><h2 id="_2-node-rsa" tabindex="-1">2. node-rsa <a class="header-anchor" href="#_2-node-rsa" aria-hidden="true">#</a></h2><p>js有个库node-rsa,可以实现rsa算法，实现非对称加密。代码如下:</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> NodeRSA </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">node-rsa</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> key </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NodeRSA</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">512</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> text </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello RSA!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> encrypted </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">encrypt</span><span style="color:#A6ACCD;">(text</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">base64</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">encrypted: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> encrypted)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> decrypted </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">decrypt</span><span style="color:#A6ACCD;">(encrypted</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">decrypted: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> decrypted)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 私钥签名</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> result2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sign</span><span style="color:#A6ACCD;">(text</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">base64</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">signed: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> result2)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 公钥验签</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> result3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">verify</span><span style="color:#A6ACCD;">(text</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> result2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">base64</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">verifyed: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> result3)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>上面的代码就是要记住，加密（encrypt），解密（decrypt），签名（sign），验签（verify）这几个操作。</p><h2 id="_3-第三方-ca-存在的意义" tabindex="-1">3. 第三方（CA）存在的意义 <a class="header-anchor" href="#_3-第三方-ca-存在的意义" aria-hidden="true">#</a></h2><p>上文说到需要把公钥给第三方，为什么需要第三方呢？有一个鲍勃，苏珊和道格的故事。鲍勃有自己的公钥和私钥，他把公钥放在某个网站上，苏珊从网站上下载鲍勃的公钥。苏珊给鲍勃写信，用鲍勃的公钥加密，鲍勃收到信后，用自己的私钥解密。回信的时候鲍勃在信的结尾加上自己用私钥的签名，苏珊收到信之后，用鲍勃的公钥去验签，返回true则表示是鲍勃的回信。由于公钥是在网站上的，所以道格把自己的公钥也放在了网站上，说是鲍勃的公钥，假如之前苏珊不知道，下载了道格的公钥，然后用道格的公钥去加密，道格拦截到苏珊的信，用自己的私钥解密，再回信并加自己的私钥签名，苏珊用手里的公钥去验签发现正确，但总感觉不对劲，最后决定找第三方机构CA。</p><p>CA的作用就是大家把需要认证的公钥给我，我给做证书，实际就是用CA的私钥去签名，内容包括公钥/姓名/网站/域名等，签完名后和签名一起生成证书。鲍勃把自己的公钥做完认证后，鲍勃就可以把自己的证书给苏珊，苏珊用CA的公钥去验签，发现是true，则表明证书里的公钥姓名是正确的。道格没办法去改动证书，修改鲍勃证书里的名字或者私钥，苏珊会验签不通过。把自己的证书给苏珊，苏珊会发现姓名不对。这就是CA的作用。</p><h2 id="_4-密码学的历史" tabindex="-1">4. 密码学的历史 <a class="header-anchor" href="#_4-密码学的历史" aria-hidden="true">#</a></h2><p>第一个阶段是算法流派，通过复杂算法对字符加密，再通过相反的算法去解密，比如a，转成字节码，先加一，再减二等操作后生成密文，密文解密就是先加二，再减一，转成字符。常用算法如base6-4等，实际是编码。 第二个阶段是对称加密流派，通过一个确定的算法，只是秘钥不一样，到这个阶段，核心从算法变成了秘钥，常见算法比如DES，AES。 第三阶段是非对称加密，对称加密的确定是加密和解密用一个秘钥，那么秘钥的传递就是个问题，只要拦截到秘钥，就毫无秘密可言。非对称加密是有两个秘钥，一个公钥，一个私钥。公钥可以传递用于加密，私钥自己留着用于解密，这就完美的解决了对称加密的问题，非对称加密的常见算法有RSA等。</p><p>实际使用的时候会先通过非对称加密生成一个特殊秘钥，后续的通话就是基于这个特殊秘钥的对称加密。因为非对称加密算法耗时间，所以通过它拿到特殊秘钥后，就可以使用对称加密来进行之后的活动。</p><p>上面讲的都是可逆的加密，还有不可逆的加密，如MD-X和SH-X系列，前者是信息摘要（Message Digest）的缩写，后者是安全散列（Secure Hash）的缩写。</p><h2 id="_5-https-ssl-tls" tabindex="-1">5. https/ssl/tls <a class="header-anchor" href="#_5-https-ssl-tls" aria-hidden="true">#</a></h2><p>https就是http+ssl/tls；网景公司在94年发布ssl1.0,95年发布ssl2.0,96年发布ssl3.0;99年互联网标准化组织ISOC接替NetScape公司接替网景公司发布tls1.0(ssl3.1),06年发布tls1.1(ssl3.2)，08发布tls1.2(ssl3.3)。ssl/tls的核心思路就是采用非对称加密算法，整个过程如下：</p><ol><li>客户端给服务器发hello(实际是随机数A)</li><li>服务器给客户端发证书和另一个随机数B</li><li>客户端校验证书，校验证书中的域名和当前访问的域名是否一致，然后用证书中的公钥加密随机数C给服务器，客户端握手阶段结束</li><li>服务器用私钥解密客户端发来的随机数C，结合之前的随机数一起生成对称秘钥，之后和客户端对话都采用对称秘钥加解密，服务器端握手阶段结束。</li><li>之后就是对称加解密的http通话。</li></ol>`,20),e=[o];function t(c,r,D,y,F,A){return n(),a("div",null,e)}const d=s(p,[["render",t]]);export{i as __pageData,d as default};
